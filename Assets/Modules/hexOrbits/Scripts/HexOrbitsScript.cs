using KeepCoding;
using System;
using System.Collections;
using UnityEngine;
using Rnd = UnityEngine.Random;


public class HexOrbitsScript : ModuleScript
{
    /*
    I know you're going to copy over this basic template for new modules, so heres a reminder that you shouldn't get rid of:
    MAKE SURE TO ATTACH mod.bundle TO MODULE PREFABS AND ALL SOUNDS! If hexVariants 2.0 happens again, there is no one to blame but yourself.
    (+ a thank you to emik and river for making sure the time of which issues were happening was only a day long)
    */

    public KMSelectable Screen;
    public KMSelectable[] Buttons;

    public Texture[] ShapeTextures;
    public Renderer FastShape, SlowShape, DecorCube;

    private static int[] _tableValues = new int[64]
    {
        0,  1,  2,  15, 0,  5,  4,  14,
        14, 13, 6,  3,  6,  6,  8,  11,
        4,  1,  8,  1,  15, 9,  14, 10,
        15, 12, 12, 10, 9,  5,  14, 7,
        8,  1,  15, 0,  4,  12, 1,  7,
        5,  7,  2,  11, 14, 3,  5,  12,
        3,  14, 11, 4,  7,  10, 1,  7,
        15, 3,  9,  9,  4,  8,  15, 15
    };
    //this is the hexOrbits static array, generated by a program made by emik - it works, somehow

    /*here's the array in hexadecimal for reference:
    012F054E
    ED63668B
    4181F9EA
    FCCA95E7
    81F04C17
    572BE35C
    3EB47A17
    F39948FF
    */

    // note to self - fields can only be initiated outside of functions, otherwise it's a local. to modify values, have them outside of any function. you will forget this, and look here to remember it
    internal int[] stageValues = new int[5];

    private int _step;

    private string[] _directions = new string[4] { "Up", "Right", "Down", "Left" };

    /// <summary>
    /// Stage counter for the module. (-1 = init, 0-3 = Stages)
    /// </summary>
    private int _stage = -1;

    private int _lastInput = -1, _stageDisplay = -1;

    private float _shrinkAnimate;

    private Routine<int> routine;


    //base functions, made easy with e̶m̶i̶k̶b̶a̶s̶e̶m̶o̶d̶u̶l̶e̶s̶  keep coding and nobody explodes!

    private void Start()
    {
        routine = new Routine<int>(OnSubmit, this);

        Buttons.Assign(onInteract: HandleButtons);
        Screen.Assign(onInteract: HandleScreen);

        int locationSeed = Rnd.Range(0, _tableValues.Length),
            movementSeed = Rnd.Range(1, 5);
        Log("hexOrbits loaded! Starting at location {0}, with {1}-step movement.".Form(locationSeed + 1, movementSeed));

        //pointer locations are actually all predetermined from the start! the manual technically lies!

        for (int i = 0; i < stageValues.Length; i++)
        {
            stageValues[i] = _tableValues.ElementAtWrap(locationSeed + (movementSeed * i));
        }

        Cache(GetComponentsInChildren<TextMesh>)[0].text = "hexOrbits - Idle";

        Log("The 4 array cells are: {0}, {1}, {2}, {3}. (with locations of: {4}, {5}, {6}, {7})".Form(ToHex(stageValues[0]), ToHex(stageValues[1]), ToHex(stageValues[2]), ToHex(stageValues[3]), locationSeed + 1, (locationSeed + movementSeed + 1) % 64, (locationSeed + (movementSeed * 2) + 1) % 64, (locationSeed + (movementSeed * 3) + 1) % 64));

        Log("This module's solution is {0} (in location {1}), and can be submitted by pressing {2}, {3}.".Form(ToHex(stageValues[4]), (locationSeed + (movementSeed * 4) + 1) % 64, _directions[stageValues[4] / 4], _directions[stageValues[4] % 4]));
    }

    private void FixedUpdate()
    {
        _step++;
        FastShape.transform.localRotation = Quaternion.Euler(0, _step * Mathf.PI, 0);
        SlowShape.transform.localRotation = Quaternion.Euler(0, _step, 0);
        DecorCube.transform.localRotation = Quaternion.Euler((_step * Mathf.PI) / 2.5f, _step, (_step * Mathf.PI) / 4f);
        if (_shrinkAnimate > 0)
        {
            _shrinkAnimate -= 0.0007f;
            FastShape.transform.localScale = new Vector3(_shrinkAnimate, 1, _shrinkAnimate);
            SlowShape.transform.localScale = new Vector3(_shrinkAnimate, 1, _shrinkAnimate);
        }
    }

    private void HandleButtons(int arg1)
    {
        ButtonEffect(Buttons[arg1], 1, "OrbitsButtonPress");
        if (IsSolved || routine.IsRunning)
            return;
        if (_lastInput != -1)
        {
            routine.Start(arg1);
        }
        else
        {
            _lastInput = arg1;
            Cache(GetComponentsInChildren<TextMesh>)[0].text = "Submitting... - {0}, ?".Form(_directions[_lastInput]);
        }
    }
    
    private void HandleScreen()
    {
        ButtonEffect(Screen, 1, _stageDisplay == -1 ? "OrbitsActivate" : "OrbitsStep");
        if (IsSolved)
            return;
        _stage = ++_stage % 4;
        RenderCurrentStage();
    }

    private IEnumerator OnSubmit(int arg1)
    {
        Cache(GetComponentsInChildren<TextMesh>)[0].text = "Submitting - {0}, {1}".Form(_directions[_lastInput], _directions[arg1]);
        PlaySound("OrbitsAnticipation");

        _shrinkAnimate = 0.07f;

        yield return new WaitForSecondsRealtime(2.5f);

        int submission = (_lastInput * 4) + arg1;

        if (submission == stageValues[4])
        {
            Cache(GetComponentsInChildren<TextMesh>)[0].text = "hexOrbits - Complete!";
            PlaySound("OrbitsSolve");

            SlowShape.material.mainTexture = ShapeTextures[0];
            FastShape.material.mainTexture = ShapeTextures[4];

            Solve("Submitted {0}, expected {1} - Module solved!".Form(ToHex(submission), ToHex(stageValues[4])));
        }
        else
        {
            Cache(GetComponentsInChildren<TextMesh>)[0].text = "hexOrbits - Error!";
            PlaySound("OrbitsStrike");

            Strike("Submitted {0}, expected {1} - Strike!".Form(ToHex(submission), ToHex(stageValues[4])));
        }

        FastShape.transform.localScale = new Vector3(0.07f, 1, 0.07f);
        SlowShape.transform.localScale = new Vector3(0.07f, 1, 0.07f);

        _lastInput = -1;
    }

    private void RenderCurrentStage()
    {
        _stageDisplay = (_stageDisplay + 1) % 4;
        int currentStage = stageValues[_stage];
        SlowShape.material.mainTexture = ShapeTextures[currentStage / 4];
        FastShape.material.mainTexture = ShapeTextures[currentStage % 4];
        Cache(GetComponentsInChildren<TextMesh>)[0].text = "hexOrbits - Index {0} of 4".Form(_stageDisplay + 1);
    }


    private static string ToHex(int i)
    {
        return Convert.ToString(i, 16).ToUpperInvariant();
    }

}
 